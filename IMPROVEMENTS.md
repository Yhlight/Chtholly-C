# Chtholly 编译器改进建议报告

## 1. 概述

经过对 Chtholly 编译器代码库的深入审查，我们发现当前的设计虽然在早期开发中卓有成效，但随着语言功能的日益复杂，其架构上的局限性也愈发明显。最核心的问题在于**缺乏一个独立的语义分析阶段**，导致类型检查、作用域分析和错误报告等关键任务与代码转换（Transpiler）过程紧密耦合。

这种设计不仅增加了代码的维护成本，也限制了语言的进一步发展。本报告旨在系统性地分析当前编译器在**解析器与错误恢复**、**类型系统与语义分析**、**代码生成质量**和**整体架构**四个方面存在的问题，并提出一套切实可行的改进方案，以期构建一个更健壮、可维护和可扩展的编译器。

## 2. 解析器与错误恢复

### 2.1. 当前实现

- 解析器（`Parser.cpp`）采用 `try-catch` 机制捕获 `ParseError` 异常，并调用 `synchronize()` 函数进行错误恢复。
- `synchronize()` 的策略相对简单，主要是通过丢弃 token 直到找到下一个语句的起始关键字（如 `func`, `let`, `if` 等）或分号。

### 2.2. 问题分析

- **恢复能力有限**：当错误发生在嵌套结构（如 `if` 语句块、`for` 循环体）或复杂表达式内部时，`synchronize()` 可能会丢弃过多未出错的代码，导致后续产生连锁的“伪”错误，干扰开发者对真正问题的定位。
- **错误报告不精确**：由于恢复点较远，解析器可能无法提供关于错误最直接上下文的精确信息。

### 2.3. 改进建议

- **引入更精细的同步点**：除了语句起始关键字，还应将 `}`、`)` 等闭合符号作为重要的同步点。当解析器在期望一个特定 token 而不得时，可以尝试同步到更高层级的语法单元，从而减少代码的丢弃。
- **实现恐慌模式（Panic Mode）的增强**：在捕获异常后，可以根据当前解析的上下文（例如，是否在函数体内、是否在解析表达式）选择不同的恢复策略，而不是单一地跳到下一个语句。
- **引入选择性跟随集（Selective Follow Set）恢复**：对于特定的非终结符，预先定义一个“合法后继” token 集合。当解析出错时，解析器可以尝试跳过 token 直到找到这个集合中的一个成员，从而在更小的范围内恢复。

## 3. 类型系统与语义分析

### 3.1. 当前实现

- 编译器的“语义分析”功能——主要是类型推断和检查——几乎完全由 `Transpiler.cpp` 中的 `get_type` 函数承担。
- `get_type` 函数通过 `dynamic_cast` 和一长串的 `if-else` 逻辑，递归地确定表达式的类型。
- 变量作用域和符号表管理也分散在 `Transpiler` 的 `enterScope`/`exitScope` 和 `define`/`lookup` 方法中。

### 3.2. 问题分析

- **职责耦合严重**：`get_type` 函数不仅要推断类型，还要处理特定函数（如 `fs_read`、`math::sqrt`）的返回类型，这使得它成为了一个巨大的、难以维护的“上帝函数”。
- **可扩展性差**：每当为语言添加一个新的函数、方法或操作符时，都需要修改 `get_type` 和其他相关的 `handle...` 函数，增加了引入错误的风险。
- **错误报告滞后**：类型错误只能在转换（transpilation）阶段被发现，此时已经脱离了最直接的语法上下文。理想情况下，语义错误应在解析生成 AST 之后、代码生成之前被捕获。
- **缺乏独立的符号表管理**：当前的作用域管理与 `Transpiler` 绑定过深，不利于实现更复杂的语言特性，如闭包、命名空间等。

### 3.3. 改进建议

- **引入独立的语义分析阶段（Resolver/Analyzer）**：
    - 在解析（Parsing）和转换（Transpiling）之间增加一个新的编译器阶段，专门负责语义分析。
    - 这个新阶段将遍历 AST，构建一个完整的、层次化的符号表，并对每个节点进行类型检查。
- **设计独立的类型系统**：
    - 创建一套独立的类型类（如 `Type`, `IntType`, `FunctionType`, `StructType`），而不是在 `TypeInfo` 中使用字符串来表示类型。这将使类型比较和规则定义更加严谨和高效。
- **实现基于访问者模式的语义分析器**：
    - 创建一个新的 `StmtVisitor` 和 `ExprVisitor` 实现，该实现将负责：
        1. **变量解析**：确认每个变量在使用时都已被声明。
        2. **类型检查**：验证操作符、函数调用和赋值语句的类型兼容性。
        3. **函数返回类型验证**：确保 `return` 语句的类型与函数声明一致。
        4. **Trait 实现验证**：检查 `impl` 块中的方法签名是否与 `trait` 定义匹配。
- **将 `get_type` 的功能解耦**：
    - 在语义分析阶段完成后，每个 `Expr` 节点都应该被“装饰”或关联上其类型信息。
    - `Transpiler` 在代码生成时，应直接从 AST 节点获取类型信息，而不是重新计算。这使得 `Transpiler` 的职责可以收缩到纯粹的代码生成。

## 4. 代码生成质量

### 4.1. 当前实现

- `Transpiler.cpp` 包含大量 `handle...Function` 和 `handle...MethodCall` 辅助函数，用于将 Chtholly 的标准库调用转换为 C++ 代码。
- 许多功能（如 `string::split`, `fs_read`）依赖于在最终的 C++ 文件中注入预先编写好的 C++ 辅助函数（如 `chtholly_string_split`）。

### 4.2. 问题分析

- **生成的 C++ 代码可读性差**：注入的辅助函数和复杂的 lambda 表达式（用于模拟某些行为）使得生成的 C++ 代码难以阅读和调试。
- **依赖 C++ 标准库实现**：过于紧密地依赖 C++ 的特定实现（例如，`std::vector` 的 `pop_back` 是 `void`）导致需要编写变通代码（workarounds）。

### 4.3. 改进建议

- **构建一个更抽象的运行时库**：
    - 与其在每个文件中注入大量辅助函数，不如创建一个小型的、可复用的运行时库（例如 `chtholly_runtime.h`/`.cpp`），并在编译时将其与生成的代码链接。
    - 这个运行时库可以包含 Chtholly 核心类型（如字符串、动态数组）的定义和操作，从而使生成的代码更简洁，更接近 Chtholly 的语义。
- **优化代码生成模式**：
    - 对于常见的模式，如方法调用，可以探索更直接的转换方式，减少对立即调用 lambda 表达式（IILE）的依赖。
    - 在语义分析阶段收集足够的信息，可以帮助 `Transpiler` 生成更优化、更简洁的 C++ 代码。

## 5. 整体架构

### 5.1. 当前实现

- 编译器的主流程是：`Lexer -> Parser -> Transpiler`。
- 语义分析和代码生成紧密耦合在 `Transpiler` 中。

### 5.2. 问题分析

- **单体式后端（Monolithic Backend）**：当前的 `Transpiler` 同时承担了多个阶段的任务，违反了单一职责原则。
- **不利于未来发展**：如果未来 Chtholly 希望支持多个后端（例如，除了 C++，还支持生成 LLVM IR 或 WebAssembly），当前的架构将极难扩展。

### 5.3. 改进建议

- **重构为多阶段编译器架构**：
    - **前端（Frontend）**：
        1. `Lexer`：词法分析，生成 token 流。
        2. `Parser`：语法分析，生成 AST。
        3. `Resolver`/`Analyzer`：**新增的**语义分析阶段，对 AST 进行类型检查和符号解析，并用类型信息“装饰” AST。
    - **中端（Mid-end，可选）**：
        - 未来可以引入一个或多个中间表示（IR），用于平台无关的优化。
    - **后端（Backend）**：
        1. `Transpiler`：代码生成器，将装饰过的 AST 转换为目标语言（当前是 C++）。它的职责将变得非常纯粹，只需关注代码的直接翻译。
- **明确各阶段的职责**：
    - **Parser** 只负责语法，不关心类型或变量是否已声明。
    - **Resolver** 负责所有与符号和类型相关的静态检查。
    - **Transpiler** 假设 AST 在语义上是完全正确的，只负责生成代码。

## 6. 结论

Chtholly 编译器已经具备了坚实的基础，但要支持语言的长期发展，必须进行架构上的演进。我们强烈建议**引入一个独立的语义分析阶段**作为最高优先级。这将是解决当前大多数问题的关键，并为构建一个更强大、更可靠的编译器铺平道路。

我们建议将 `RoadMap.md` 的下一阶段目标调整为实现 `Resolver`，并逐步将类型检查逻辑从 `Transpiler` 中迁移出去。这项工作可以分步进行，例如，首先实现变量解析，然后是函数解析，最后是完整的类型检查。这将是一个具有挑战性但非常有价值的重构任务。
